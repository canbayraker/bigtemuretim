"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var net_1 = require("net");
var util_1 = require("util");
var S7Comm = /** @class */ (function () {
    function S7Comm(ConnectionConfig) {
        this.silentMode = false; // If true, hidde all logs
        this.effectiveDebugLevel = 0; // Only show logs equal or lower that this number
        this.writeReqHeader = Buffer.from([0x03, 0x00, 0x00, 0x1f, 0x02, 0xf0, 0x80, 0x32, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x05, 0x01]);
        this.readReqHeader = Buffer.from([0x03, 0x00, 0x00, 0x1f, 0x02, 0xf0, 0x80, 0x32, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x04, 0x01]);
        this.connectReq = Buffer.from([0x03, 0x00, 0x00, 0x16, 0x11, 0xe0, 0x00, 0x00, 0x00, 0x02, 0x00, 0xc0, 0x01, 0x0a, 0xc1, 0x02, 0x01, 0x00, 0xc2, 0x02, 0x01, 0x02]);
        this.negotiatePDU = Buffer.from([0x03, 0x00, 0x00, 0x19, 0x02, 0xf0, 0x80, 0x32, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x08, 0x00, 0x08, 0x03, 0xc0]);
        this.maxGap = 5; // This is the byte tolerance for optimize
        this.requestMaxParallel = 8; // Our expected parrallels jobs
        this.requestMaxPDU = 960; // Our expected bytes size that we can send to the PLC
        this.readReq = Buffer.alloc(1500);
        this.writeReq = Buffer.alloc(1500);
        this.client = undefined;
        this.isoConnectionState = 'disconnected';
        this.maxPDU = 960;
        this.maxParallel = 8;
        this.parallelJobsNow = 0;
        this.doNotOptimize = false;
        this.connectCallback = undefined;
        this.globalTimeout = 1500; // Each packet sent to the PLC has a timeout that trigger a timeout function
        this.rack = 0;
        this.slot = 1;
        this.localTSAP = undefined;
        this.remoteTSAP = undefined;
        this.requestQueue = [];
        this.sentReadPacketArray = []; // Read packets sent, and waiting for response
        this.sentWritePacketArray = []; // Write packets sent, and waiting for response
        this.masterSequenceNumber = 0; // This increment on every packet sent to the PLC, whit them we can indendify each ones
        this.readRequestSequence = 0; // This increment on every read packet that are not splitter due a quantity of bytes that we can send, whit them we can identify parts
        this.writeRequestSequence = 0; // This increment on every write packet that are not splitter due a quantity of bytes that we can send, whit them we can identify parts
        this.directionsTranslated = {};
        this.storedAdresses = [];
        this.translationCB = this.doNothing;
        this.connectionId = undefined;
        this.connectCBIssued = false;
        if (typeof ConnectionConfig.silentMode !== 'undefined') {
            this.silentMode = ConnectionConfig.silentMode;
        }
        if (typeof ConnectionConfig === 'undefined') {
            ConnectionConfig = { port: 102, host: '0.0.0.0' };
        }
        if (typeof ConnectionConfig.rack !== 'undefined') {
            this.rack = ConnectionConfig.rack;
        }
        if (typeof ConnectionConfig.slot !== 'undefined') {
            this.slot = ConnectionConfig.slot;
        }
        if (typeof ConnectionConfig.localTSAP !== 'undefined') {
            this.localTSAP = ConnectionConfig.localTSAP;
        }
        if (typeof ConnectionConfig.remoteTSAP !== 'undefined') {
            this.remoteTSAP = ConnectionConfig.remoteTSAP;
        }
        if (typeof ConnectionConfig.connectionName === 'undefined') {
            this.connectionId = ConnectionConfig.host + ' S' + this.slot;
        }
        else {
            this.connectionId = ConnectionConfig.connectionName;
        }
        this.ConnectionConfig = ConnectionConfig;
        this.connectCBIssued = false;
    }
    S7Comm.prototype.outputLog = function (txt, debugLevel, id) {
        if (this.silentMode)
            return;
        var idtext;
        if (typeof id === 'undefined') {
            idtext = '';
        }
        else {
            idtext = ' ' + id;
        }
        if (typeof debugLevel === 'undefined' || this.effectiveDebugLevel >= debugLevel) {
            console.log('[' + process.hrtime.bigint() + idtext + '] ' + util_1.format(txt));
        }
    };
    S7Comm.prototype.doNothing = function (arg) {
        return arg;
    };
    S7Comm.prototype.setTranslationCB = function (variables) {
        var _this = this;
        Object.keys(variables).forEach(function (key) {
            if (typeof variables[key] === 'undefined' || variables[key] === '') {
                delete variables[key];
            }
        });
        this.directionsTranslated = variables;
        this.translationCB = function (tag) {
            if (_this.directionsTranslated[tag]) {
                return _this.directionsTranslated[tag];
            }
            else {
                return tag;
            }
        };
    };
    S7Comm.prototype.rejectAllRequestQueue = function () {
        this.outputLog('We detect a connection error, we are rejecting all request');
        this.lastError = 'We detect a connection error, we are rejecting all request';
        for (var i = 0; i < this.requestQueue.length; i++) {
            if (this.requestQueue[i].action === 'read') {
                var req = this.requestQueue[i].request;
                for (var u = 0; u < req.requestList.length; u++) {
                    req.requestList[u].addresses[0].promiseReject(this.lastError);
                }
            }
            else {
                var req = this.requestQueue[i].request;
                req.requestList[0].itemReference.address.promiseReject(this.lastError);
            }
        }
        this.requestQueue = [];
    };
    S7Comm.prototype.stringToS7Addr = function (readOrWrite, addr, useraddr) {
        var errMessage = '';
        var address = this.Address;
        if (useraddr === '_COMMERR') {
            address.valid = false;
            return address;
        } // Special-case for communication error status - this variable returns true when there is a communications error
        var splitString = addr.split(',');
        if (splitString.length === 0 || splitString.length > 2) {
            errMessage = 'Error - String Couldnt Split Properly.';
            this.lastError = errMessage;
            this.outputLog(errMessage);
            address.valid = false;
            return address;
        }
        if (splitString.length > 1) {
            // Must be DB type
            address.Type = 'DB'; // Hard code
            var splitString2 = splitString[1].split('.');
            address.dataType = splitString2[0].replace(/[0-9]/gi, '').toUpperCase(); // Clear the numbers
            if (address.dataType === 'X' && splitString2.length === 3) {
                address.arrayLength = parseInt(splitString2[2], 10);
            }
            else if ((address.dataType === 'S' || address.dataType === 'STRING') && splitString2.length === 3) {
                address.dataTypeLength = parseInt(splitString2[1], 10) + 2; // With strings, add 2 to the length due to S7 header
                address.arrayLength = parseInt(splitString2[2], 10); // For strings, array length is now the number of strings
            }
            else if ((address.dataType === 'S' || address.dataType === 'STRING') && splitString2.length === 2) {
                address.dataTypeLength = parseInt(splitString2[1], 10) + 2; // With strings, add 2 to the length due to S7 header
                address.arrayLength = 1;
            }
            else if (address.dataType !== 'X' && splitString2.length === 2) {
                address.arrayLength = parseInt(splitString2[1], 10);
            }
            else {
                address.arrayLength = 1;
            }
            if (address.arrayLength <= 0) {
                errMessage = 'Zero length arrays not allowed, returning undefined';
                this.lastError = errMessage;
                this.outputLog(errMessage);
                address.valid = false;
                return address;
            }
            // Get the data block number from the first part.
            address.dbNumber = parseInt(splitString[0].replace(/[A-z]/gi, ''), 10);
            // Get the data block byte offset from the second part, eliminating characters.
            // Note that at this point, we may miss some info, like a "T" at the end indicating TIME data type or DATE data type or DT data type.  We ignore these.
            // This is on the TODO list.
            address.offset = parseInt(splitString2[0].replace(/[A-z]/gi, ''), 10); // Get rid of characters
            // Get the bit offset
            if (splitString2.length > 1 && address.dataType === 'X') {
                address.bitOffset = parseInt(splitString2[1], 10);
                if (isNaN(address.bitOffset) || address.bitOffset < 0 || address.bitOffset > 7) {
                    errMessage = 'Invalid bit offset specified for address ' + addr;
                    this.lastError = errMessage;
                    this.outputLog(errMessage);
                    address.valid = false;
                    return address;
                }
            }
        }
        else {
            // Must not be DB.  We know there's no comma.
            var splitString2 = addr.split('.');
            switch (splitString2[0].replace(/[0-9]/gi, '')) {
                /* We do have the memory areas:
                  "input", "peripheral input", "output", "peripheral output", ",marker", "counter" and "timer" as I, PI, Q, PQ, M, C and T.
                   Datablocks are handles somewere else.
                   We do have the data types:
                   "bit", "byte", "char", "word", "int16", "dword", "int32", "real" as X, B, C, W, I, DW, DI and R
                   What about "uint16", "uint32"
                */
                /* All styles of peripheral IOs (no bit access allowed) */
                case 'PIB':
                case 'PEB':
                case 'PQB':
                case 'PAB':
                    address.Type = 'P';
                    address.dataType = 'BYTE';
                    break;
                case 'PIC':
                case 'PEC':
                case 'PQC':
                case 'PAC':
                    address.Type = 'P';
                    address.dataType = 'CHAR';
                    break;
                case 'PIW':
                case 'PEW':
                case 'PQW':
                case 'PAW':
                    address.Type = 'P';
                    address.dataType = 'WORD';
                    break;
                case 'PII':
                case 'PEI':
                case 'PQI':
                case 'PAI':
                    address.Type = 'P';
                    address.dataType = 'INT';
                    break;
                case 'PID':
                case 'PED':
                case 'PQD':
                case 'PAD':
                    address.Type = 'P';
                    address.dataType = 'DWORD';
                    break;
                case 'PIDI':
                case 'PEDI':
                case 'PQDI':
                case 'PADI':
                    address.Type = 'P';
                    address.dataType = 'DINT';
                    break;
                case 'PIR':
                case 'PER':
                case 'PQR':
                case 'PAR':
                    address.Type = 'P';
                    address.dataType = 'REAL';
                    break;
                /* All styles of standard inputs (in oposit to peripheral inputs) */
                case 'I':
                case 'E':
                    address.Type = 'I';
                    address.dataType = 'X';
                    break;
                case 'IB':
                case 'EB':
                    address.Type = 'I';
                    address.dataType = 'BYTE';
                    break;
                case 'IC':
                case 'EC':
                    address.Type = 'I';
                    address.dataType = 'CHAR';
                    break;
                case 'IW':
                case 'EW':
                    address.Type = 'I';
                    address.dataType = 'WORD';
                    break;
                case 'II':
                case 'EI':
                    address.Type = 'I';
                    address.dataType = 'INT';
                    break;
                case 'ID':
                case 'ED':
                    address.Type = 'I';
                    address.dataType = 'DWORD';
                    break;
                case 'IDI':
                case 'EDI':
                    address.Type = 'I';
                    address.dataType = 'DINT';
                    break;
                case 'IR':
                case 'ER':
                    address.Type = 'I';
                    address.dataType = 'REAL';
                    break;
                /* All styles of standard outputs (in oposit to peripheral outputs) */
                case 'Q':
                case 'A':
                    address.Type = 'Q';
                    address.dataType = 'X';
                    break;
                case 'QB':
                case 'AB':
                    address.Type = 'Q';
                    address.dataType = 'BYTE';
                    break;
                case 'QC':
                case 'AC':
                    address.Type = 'Q';
                    address.dataType = 'CHAR';
                    break;
                case 'QW':
                case 'AW':
                    address.Type = 'Q';
                    address.dataType = 'WORD';
                    break;
                case 'QI':
                case 'AI':
                    address.Type = 'Q';
                    address.dataType = 'INT';
                    break;
                case 'QD':
                case 'AD':
                    address.Type = 'Q';
                    address.dataType = 'DWORD';
                    break;
                case 'QDI':
                case 'ADI':
                    address.Type = 'Q';
                    address.dataType = 'DINT';
                    break;
                case 'QR':
                case 'AR':
                    address.Type = 'Q';
                    address.dataType = 'REAL';
                    break;
                /* All styles of marker */
                case 'M':
                    address.Type = 'M';
                    address.dataType = 'X';
                    break;
                case 'MB':
                    address.Type = 'M';
                    address.dataType = 'BYTE';
                    break;
                case 'MC':
                    address.Type = 'M';
                    address.dataType = 'CHAR';
                    break;
                case 'MW':
                    address.Type = 'M';
                    address.dataType = 'WORD';
                    break;
                case 'MI':
                    address.Type = 'M';
                    address.dataType = 'INT';
                    break;
                case 'MD':
                    address.Type = 'M';
                    address.dataType = 'DWORD';
                    break;
                case 'MDI':
                    address.Type = 'M';
                    address.dataType = 'DINT';
                    break;
                case 'MR':
                    address.Type = 'M';
                    address.dataType = 'REAL';
                    break;
                /* Timer */
                case 'T':
                    address.Type = 'T';
                    address.dataType = 'TIMER';
                    break;
                /* Counter */
                case 'C':
                    address.Type = 'C';
                    address.dataType = 'COUNTER';
                    break;
                default:
                    errMessage = 'Failed to find a match for ' + splitString2[0];
                    this.lastError = errMessage;
                    this.outputLog(errMessage);
                    address.valid = false;
                    return address;
            }
            address.bitOffset = 0;
            if (splitString2.length > 1 && address.dataType === 'X') {
                // Bit and bit array
                address.bitOffset = parseInt(splitString2[1].replace(/[A-z]/gi, ''), 10);
                if (splitString2.length > 2) {
                    // Bit array only
                    address.arrayLength = parseInt(splitString2[2].replace(/[A-z]/gi, ''), 10);
                }
                else {
                    address.arrayLength = 1;
                }
            }
            else if (splitString2.length > 1 && address.dataType !== 'X') {
                // Bit and bit array
                address.arrayLength = parseInt(splitString2[1].replace(/[A-z]/gi, ''), 10);
            }
            else {
                address.arrayLength = 1;
            }
            address.dbNumber = 0;
            address.offset = parseInt(splitString2[0].replace(/[A-z]/gi, ''), 10);
        }
        if (isNaN(address.offset) || address.offset < 0) {
            errMessage = 'Invalid byte offset specified for address ' + addr;
            this.lastError = errMessage;
            this.outputLog(errMessage);
            address.valid = false;
            return address;
        }
        if (address.dataType === 'DI') {
            address.dataType = 'DINT';
        }
        if (address.dataType === 'I') {
            address.dataType = 'INT';
        }
        if (address.dataType === 'DW') {
            address.dataType = 'DWORD';
        }
        if (address.dataType === 'R') {
            address.dataType = 'REAL';
        }
        switch (address.dataType) {
            case 'REAL':
            case 'DWORD':
            case 'DINT':
                address.dataTypeLength = 4;
                break;
            case 'INT':
            case 'WORD':
            case 'TIMER':
            case 'COUNTER':
                address.dataTypeLength = 2;
                break;
            case 'X':
            case 'B':
            case 'C':
            case 'BYTE':
            case 'CHAR':
                address.dataTypeLength = 1;
                break;
            case 'S':
            case 'STRING':
                // For strings, arrayLength and dtypelen were assigned during parsing.
                break;
            default:
                errMessage = 'Unknown data type ' + address.dataType;
                this.lastError = errMessage;
                this.outputLog(errMessage);
                address.valid = false;
                return address;
        }
        // Default
        address.transportCode = 0x04;
        switch (address.Type) {
            case 'DB':
            case 'DI':
                address.areaS7Code = 0x84;
                break;
            case 'I':
            case 'E':
                address.areaS7Code = 0x81;
                break;
            case 'Q':
            case 'A':
                address.areaS7Code = 0x82;
                break;
            case 'M':
                address.areaS7Code = 0x83;
                break;
            case 'P':
                address.areaS7Code = 0x80;
                break;
            case 'C':
                address.areaS7Code = 0x1c;
                address.transportCode = 0x09;
                break;
            case 'T':
                address.areaS7Code = 0x1d;
                address.transportCode = 0x09;
                break;
            default:
                errMessage = 'Unknown memory area entered - ' + address.dataType;
                this.lastError = errMessage;
                this.outputLog(errMessage);
                address.valid = false;
                return address;
        }
        if (address.dataType === 'X' && address.arrayLength === 1 && readOrWrite === 'write') {
            address.transportCode = 0x03;
        }
        // Save the address from the argument for later use and reference
        address.name = addr;
        address.userName = useraddr;
        if (address.dataType === 'X') {
            address.byteLength = Math.ceil((address.bitOffset + address.arrayLength) / 8);
        }
        else {
            if (address.arrayLength === 0) {
                errMessage = 'Array length cannot be 0: ' + address.name;
                this.lastError = errMessage;
                this.outputLog(errMessage);
                address.valid = false;
                return address;
            }
            address.byteLength = address.arrayLength * address.dataTypeLength;
        }
        //	outputLog(' Arr lenght is ' + address.arrayLength + ' and DTL is ' + address.dtypelen);
        address.byteLengthWithFill = address.byteLength;
        if (address.byteLengthWithFill % 2) {
            address.byteLengthWithFill += 1;
        } // S7 will add a filler byte.  Use this expected reply length for PDU calculations.
        return address;
    };
    S7Comm.prototype.stringArrayToS7AddressArray = function (items, operation) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.outputLog('Adding ' + items, 0, _this.connectionId);
            var addresses = [];
            if (typeof items === 'string' && items !== '_COMMERR') {
                var address = _this.Address;
                address = _this.stringToS7Addr(operation, _this.translationCB(items), items);
                addresses.push(address);
            }
            else if (Array.isArray(items)) {
                for (var i = 0; i < items.length; i++) {
                    if (typeof items[i] === 'string' && items[i] !== '_COMMERR') {
                        var address = _this.Address;
                        address = _this.stringToS7Addr(operation, _this.translationCB(items[i]), items[i]);
                        addresses.push(address);
                    }
                }
            }
            // Validity check.
            for (var i = 0; i < addresses.length; i++) {
                if (!addresses[i].valid) {
                    addresses.splice(i, 1);
                    // this.outputLog('Dropping an undefined request item.', 0, this.connectionId);
                    reject(new Error(_this.lastError));
                }
            }
            resolve(addresses);
        });
    };
    S7Comm.prototype.S7AddrToBuffer = function (address, totalByteLength, totalByteLengthWithFill, totalOffset, isWriting) {
        var thisBitOffset = 0;
        var theReq = Buffer.from([0x12, 0x0a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        // First 3 bytes (0,1,2) is constant, sniffed from other traffic, for S7 head.
        // Next one is "byte length" - we always request X number of bytes - even for a REAL with length of 1 we read BYTES length of 4.
        theReq[3] = 0x02; // Byte length
        // Next we write the number of bytes we are going to read.
        if (address.dataType === 'X') {
            theReq.writeUInt16BE(totalByteLength, 4);
            if (isWriting && address.arrayLength === 1) {
                // Byte length will be 1 already so no need to special case this.
                theReq[3] = 0x01; // 1 = "BIT" length
                // We need to specify the bit offset in this case only.  Normally, when reading, we read the whole byte anyway and shift bits around.  Can't do this when writing only one bit.
                thisBitOffset = address.bitOffset;
            }
        }
        else if (address.Type === 'TIMER' || address.Type === 'COUNTER') {
            theReq.writeUInt16BE(1, 4);
            theReq.writeUInt8(address.areaS7Code, 3);
        }
        else {
            theReq.writeUInt16BE(totalByteLength, 4);
        }
        // Then we write the data block number.
        theReq.writeUInt16BE(address.dbNumber, 6);
        // Write our area crossing pointer.  When reading, write a bit offset of 0 - we shift the bit offset out later only when reading.
        theReq.writeUInt32BE(totalOffset * 8 + thisBitOffset, 8);
        // Now we have to BITWISE OR the area code over the area crossing pointer.
        // This must be done AFTER writing the area crossing pointer as there is overlap, but this will only be noticed on large DB.
        theReq[8] |= address.areaS7Code;
        return theReq;
    };
    S7Comm.prototype.getWriteBuffer = function (s7Item) {
        var newBuffer;
        // NOTE: It seems that when writing, the data that is sent must have a "fill byte" so that data length is even only for all
        //  but the last request.  The last request must have no padding.  So we DO NOT add the padding here anymore.
        if (s7Item.address.dataType === 'X' && s7Item.address.arrayLength === 1) {
            newBuffer = Buffer.alloc(2 + 3); // Changed from 2 + 4 to 2 + 3 as padding was moved out of this function
            // Initialize, especially be sure to get last bit which may be a fill bit.
            newBuffer.writeUInt16BE(1, 2); // Might need to do something different for different trans codes
        }
        else {
            newBuffer = Buffer.alloc(s7Item.address.byteLength + 4);
            newBuffer.writeUInt16BE(s7Item.address.byteLength * 8, 2); // Might need to do something different for different trans codes
        }
        if (s7Item.writeBuffer.length < s7Item.address.byteLengthWithFill) {
            this.outputLog("Attempted to access part of the write buffer that wasn't there when writing an item.");
        }
        newBuffer[0] = 0;
        newBuffer[1] = s7Item.address.transportCode;
        s7Item.writeBuffer.copy(newBuffer, 4, 0, s7Item.address.byteLength); // Not with fill.  It might not be that long.
        return newBuffer;
    };
    S7Comm.prototype.bufferizeValue = function (address, writeValue) {
        var writeBuffer = Buffer.alloc(8192);
        var thePointer, theByte;
        theByte = 0;
        thePointer = 0; // After length and header
        if (address.arrayLength > 1) {
            // Array value.
            var bitShiftAmount = address.bitOffset;
            for (var arrayIndex = 0; arrayIndex < address.arrayLength; arrayIndex++) {
                switch (address.dataType) {
                    case 'REAL':
                        writeBuffer.writeFloatBE(writeValue[arrayIndex], thePointer);
                        break;
                    case 'DWORD':
                        writeBuffer.writeInt32BE(writeValue[arrayIndex], thePointer);
                        break;
                    case 'DINT':
                        writeBuffer.writeInt32BE(writeValue[arrayIndex], thePointer);
                        break;
                    case 'INT':
                        writeBuffer.writeInt16BE(writeValue[arrayIndex], thePointer);
                        break;
                    case 'WORD':
                        writeBuffer.writeUInt16BE(writeValue[arrayIndex], thePointer);
                        break;
                    case 'X':
                        theByte = theByte | ((writeValue[arrayIndex] === true ? 1 : 0) << bitShiftAmount);
                        // Maybe not so efficient to do this every time when we only need to do it every 8.  Need to be careful with optimizations here for odd requests.
                        writeBuffer.writeUInt8(theByte, thePointer);
                        bitShiftAmount++;
                        break;
                    case 'B':
                    case 'BYTE':
                        writeBuffer.writeUInt8(writeValue[arrayIndex], thePointer);
                        break;
                    case 'C':
                    case 'CHAR':
                        // Convert to string.
                        //??					address.writeBuffer.writeUInt8(address.writeValue.toCharCode(), thePointer);
                        writeBuffer.writeUInt8(writeValue.charCodeAt(arrayIndex), thePointer);
                        break;
                    case 'S':
                    case 'STRING':
                        // Convert to bytes.
                        writeBuffer.writeUInt8(address.dataTypeLength - 2, thePointer); // Array length is requested val, -2 is string length
                        writeBuffer.writeUInt8(Math.min(address.dataTypeLength - 2, writeValue[arrayIndex].length), thePointer + 1); // Array length is requested val, -2 is string length
                        for (var charOffset = 2; charOffset < address.dataTypeLength; charOffset++) {
                            if (charOffset < writeValue[arrayIndex].length + 2) {
                                writeBuffer.writeUInt8(writeValue[arrayIndex].charCodeAt(charOffset - 2), thePointer + charOffset);
                            }
                            else {
                                writeBuffer.writeUInt8(32, thePointer + charOffset); // write space
                            }
                        }
                        break;
                    case 'TIMER':
                    case 'COUNTER':
                        // I didn't think we supported arrays of timers and counters.
                        writeBuffer.writeInt16BE(writeValue[arrayIndex], thePointer);
                        break;
                    default:
                        this.outputLog('Unknown data type when preparing array write packet - should never happen.  Should have been caught earlier.  ' + address.dataType);
                }
                if (address.dataType == 'X') {
                    // For bit arrays, we have to do some tricky math to get the pointer to equal the byte offset.
                    // Note that we add the bit offset here for the rare case of an array starting at other than zero.  We either have to
                    // drop support for this at the request level or support it here.
                    if ((arrayIndex + address.bitOffset + 1) % 8 === 0 || arrayIndex == address.arrayLength - 1) {
                        thePointer += address.dataTypeLength;
                        bitShiftAmount = 0;
                        // Zero this now.  Otherwise it will have the same value next byte if non-zero.
                        theByte = 0;
                    }
                }
                else {
                    // Add to the pointer every time.
                    thePointer += address.dataTypeLength;
                }
            }
        }
        else {
            // Single value.
            switch (address.dataType) {
                case 'REAL':
                    writeBuffer.writeFloatBE(writeValue, thePointer);
                    break;
                case 'DWORD':
                    writeBuffer.writeUInt32BE(writeValue, thePointer);
                    break;
                case 'DINT':
                    writeBuffer.writeInt32BE(writeValue, thePointer);
                    break;
                case 'INT':
                    writeBuffer.writeInt16BE(writeValue, thePointer);
                    break;
                case 'WORD':
                    writeBuffer.writeUInt16BE(writeValue, thePointer);
                    break;
                case 'X':
                    writeBuffer.writeUInt8(writeValue === true ? 1 : 0, thePointer);
                    break;
                case 'B':
                case 'BYTE':
                    // No support as of yet for signed 8 bit.  This isn't that common in Siemens.
                    writeBuffer.writeUInt8(writeValue, thePointer);
                    break;
                case 'C':
                case 'CHAR':
                    // No support as of yet for signed 8 bit.  This isn't that common in Siemens.
                    writeBuffer.writeUInt8(writeValue.charCodeAt(0), thePointer);
                    break;
                case 'S':
                case 'STRING':
                    // Convert to bytes.
                    writeBuffer.writeUInt8(address.dataTypeLength - 2, thePointer); // Array length is requested val, -2 is string length
                    writeBuffer.writeUInt8(Math.min(address.dataTypeLength - 2, writeValue.length), thePointer + 1); // Array length is requested val, -2 is string length
                    for (var charOffset = 2; charOffset < address.dataTypeLength; charOffset++) {
                        if (charOffset < writeValue.length + 2) {
                            writeBuffer.writeUInt8(writeValue.charCodeAt(charOffset - 2), thePointer + charOffset);
                        }
                        else {
                            writeBuffer.writeUInt8(32, thePointer + charOffset); // write space
                        }
                    }
                    break;
                case 'TIMER':
                case 'COUNTER':
                    writeBuffer.writeInt16BE(writeValue, thePointer);
                    break;
                default:
                    this.outputLog('Unknown data type in write prepare - should never happen.  Should have been caught earlier.  ' + address.dataType);
            }
            thePointer += address.dataTypeLength;
        }
        return writeBuffer;
    };
    S7Comm.prototype.addressListSorter = function (a, b) {
        // Feel free to manipulate these next two lines...
        if (a.areaS7Code < b.areaS7Code) {
            return -1;
        }
        if (a.areaS7Code > b.areaS7Code) {
            return 1;
        }
        // Group first the items of the same DB
        if (a.Type === 'DB') {
            if (a.dbNumber < b.dbNumber) {
                return -1;
            }
            if (a.dbNumber > b.dbNumber) {
                return 1;
            }
        }
        // But for byte offset we need to start at 0.
        if (a.offset < b.offset) {
            return -1;
        }
        if (a.offset > b.offset) {
            return 1;
        }
        // Then bit offset
        if (a.bitOffset < b.bitOffset) {
            return -1;
        }
        if (a.bitOffset > b.bitOffset) {
            return 1;
        }
        // Then item length - most first.  This way smaller items are optimized into bigger ones if they have the same starting value.
        if (a.byteLength > b.byteLength) {
            return -1;
        }
        if (a.byteLength < b.byteLength) {
            return 1;
        }
        return 0;
    };
    S7Comm.prototype.itemListSorter = function (a, b) {
        // Feel free to manipulate these next two lines...
        if (a.address.areaS7Code < b.address.areaS7Code) {
            return -1;
        }
        if (a.address.areaS7Code > b.address.areaS7Code) {
            return 1;
        }
        // Group first the items of the same DB
        if (a.address.Type === 'DB') {
            if (a.address.dbNumber < b.address.dbNumber) {
                return -1;
            }
            if (a.address.dbNumber > b.address.dbNumber) {
                return 1;
            }
        }
        // But for byte offset we need to start at 0.
        if (a.address.offset < b.address.offset) {
            return -1;
        }
        if (a.address.offset > b.address.offset) {
            return 1;
        }
        // Then bit offset
        if (a.address.bitOffset < b.address.bitOffset) {
            return -1;
        }
        if (a.address.bitOffset > b.address.bitOffset) {
            return 1;
        }
        // Then item length - most first.  This way smaller items are optimized into bigger ones if they have the same starting value.
        if (a.address.byteLength > b.address.byteLength) {
            return -1;
        }
        if (a.address.byteLength < b.address.byteLength) {
            return 1;
        }
        return 0;
    };
    S7Comm.prototype.isOptimizableArea = function (area) {
        if (this.doNotOptimize) {
            return false;
        } // Are we skipping all optimization due to user request
        switch (area) {
            case 0x84: // db
            case 0x81: // input bytes
            case 0x82: // output bytes
            case 0x83: // memory bytes
                return true;
            default:
                return false;
        }
    };
    S7Comm.prototype.isWaiting = function () {
        if (this.requestQueue.length || this.sentReadPacketArray.length || this.sentWritePacketArray.length) {
            return true;
        }
        else {
            return false;
        }
    };
    S7Comm.prototype.packetTimeout = function (packetType, packetSeqNum) {
        var _this = this;
        this.outputLog('PacketTimeout called with type ' + packetType + ' and seq ' + packetSeqNum, 1, this.connectionId);
        if (packetType === 'ISO') {
            this.outputLog('TIMED OUT connecting to the PLC - Disconnecting', 0, this.connectionId);
            this.outputLog('Wait for 2 seconds then try again.', 0, this.connectionId);
            this.outputLog('Scheduling a reconnect from packetTimeout, connect type', 0, this.connectionId);
            clearTimeout(this.reconnectTimer);
            var timeHandler = function () {
                _this.outputLog('The scheduled reconnect from packetTimeout, connect type, is happening now', 0, _this.connectionId);
                _this.connectionReset();
            };
            this.reconnectTimer = setTimeout(timeHandler, 2000);
            return;
        }
        if (packetType === 'PDU') {
            this.outputLog('TIMED OUT waiting for PDU reply packet from PLC - Disconnecting');
            this.outputLog('Wait for 2 seconds then try again.', 0, this.connectionId);
            this.outputLog('Scheduling a reconnect from packetTimeout, connect type', 0, this.connectionId);
            clearTimeout(this.reconnectTimer);
            var timeHandler = function () {
                _this.outputLog('The scheduled reconnect from packetTimeout, PDU type, is happening now', 0, _this.connectionId);
                _this.connectionReset();
            };
            this.reconnectTimer = setTimeout(timeHandler, 2000);
            return;
        }
        if (packetType === 'read') {
            this.outputLog('READ TIMEOUT on sequence number ' + packetSeqNum, 0, this.connectionId);
            this.isoConnectionState = 'disconnected';
            this.rejectAllRequestQueue();
            if (typeof packetSeqNum !== 'undefined') {
                this.readResponse(undefined, this.findReadIndexOfSeqNum(packetSeqNum));
            }
            return;
        }
        if (packetType === 'write') {
            this.isoConnectionState = 'disconnected';
            this.rejectAllRequestQueue();
            this.outputLog('WRITE TIMEOUT on sequence number ' + packetSeqNum, 0, this.connectionId);
            if (typeof packetSeqNum !== 'undefined') {
                this.writeResponse(undefined, this.findWriteIndexOfSeqNum(packetSeqNum));
            }
            return;
        }
        this.outputLog("Unknown timeout error.  Nothing was done - this shouldn't happen.");
        this.lastError = "Unknown timeout error.  Nothing was done - this shouldn't happen.";
    };
    S7Comm.prototype.connectionReset = function () {
        this.isoConnectionState = 'disconnected';
        if (this.client) {
            this.client.destroy();
        }
        if (!this.isWaiting()) {
            this.connectNow();
        }
    };
    S7Comm.prototype.connectError = function (err) {
        // Note that the first time we are connecting we call the connectCallback, then after that, we reconnect again on a connection error
        this.isoConnectionState = 'disconnected';
        this.outputLog('We Caught a connect error: ' + err.message, 0, this.connectionId);
        this.connectionReset();
    };
    S7Comm.prototype.readWriteError = function (err) {
        this.outputLog('We Caught a read/write error ' + err.message + ' - will CLOSE the connection');
        this.isoConnectionState = 'disconnected';
    };
    S7Comm.prototype.connectionCleanup = function () {
        var _this = this;
        this.outputLog('Connection cleanup is happening');
        if (typeof this.client !== 'undefined') {
            // destroying the socket connection
            this.client.destroy();
            this.client.removeAllListeners('data');
            this.client.removeAllListeners('error');
            this.client.removeAllListeners('close');
            this.client.on('error', function () {
                _this.outputLog('TCP socket error following connection cleanup');
            });
        }
        clearTimeout(this.connectTimeout);
        clearTimeout(this.PDUTimeout);
    };
    S7Comm.prototype.findReadIndexOfSeqNum = function (seqNum) {
        for (var packetCounter = 0; packetCounter < this.sentReadPacketArray.length; packetCounter++) {
            if (this.sentReadPacketArray[packetCounter].seqNum == seqNum) {
                return packetCounter;
            }
        }
        return undefined;
    };
    S7Comm.prototype.findWriteIndexOfSeqNum = function (seqNum) {
        for (var packetCounter = 0; packetCounter < this.sentWritePacketArray.length; packetCounter++) {
            if (this.sentWritePacketArray[packetCounter].seqNum == seqNum) {
                return packetCounter;
            }
        }
        return undefined;
    };
    S7Comm.prototype.validateWriteResponse = function (theData, theItem, thePointer) {
        var errMessage = '';
        if (!theData) {
            errMessage = 'Timeout write error.';
            this.lastError = errMessage;
            this.outputLog(theItem.errCode);
            theItem.validResponseBuffer = false;
            return 0;
        }
        var remainingLength = theData.length - thePointer; // Say if length is 39 and pointer is 35 we can access 35,36,37,38 = 4 bytes.
        if (remainingLength < 1) {
            theItem.validResponseBuffer = false;
            errMessage = 'Malformed Packet - Less Than 1 Byte.';
            this.lastError = errMessage;
            this.outputLog(errMessage);
            return 0; // Hard to increment the pointer so we call it a malformed packet and we're done.
        }
        var writeResponse = theData.readUInt8(thePointer);
        theItem.writeResponse = writeResponse;
        if (writeResponse !== 0xff) {
            errMessage = 'Received write error of ' + theItem.writeResponse + ' on ' + theItem.address.name;
            this.outputLog(errMessage);
            this.lastError = errMessage;
            theItem.validResponseBuffer = false;
        }
        else {
            theItem.validResponseBuffer = true;
        }
        return thePointer + 1;
    };
    S7Comm.prototype.validateReadResponse = function (theData, request, thePointer) {
        var remainingLength;
        var errMessage = undefined;
        if (typeof theData === 'undefined') {
            remainingLength = 0;
            this.outputLog('Processing an undefined packet, likely due to timeout error');
        }
        else {
            remainingLength = theData.length - thePointer; // Say if length is 39 and pointer is 35 we can access 35,36,37,38 = 4 bytes.
        }
        var prePointer = thePointer;
        if (remainingLength < 4) {
            if (typeof theData !== 'undefined') {
                errMessage = 'Malformed Packet - Less Than 4 Bytes.';
            }
            else {
                errMessage = 'Timeout error - zero length packet';
            }
            this.lastError = errMessage;
            this.outputLog(errMessage);
            return { thePointer: 0, bufferResponse: undefined };
        }
        var reportedDataLength;
        if (request.addresses[0].transportCode === 0x04) {
            reportedDataLength = theData.readUInt16BE(thePointer + 2) / 8; // For different transport codes this may not be right.
        }
        else {
            reportedDataLength = theData.readUInt16BE(thePointer + 2);
        }
        var responseCode = theData[thePointer];
        var transportCode = theData[thePointer + 1];
        if (remainingLength == reportedDataLength + 2) {
            this.outputLog('Not last part.');
        }
        if (remainingLength < reportedDataLength + 2) {
            errMessage = 'Malformed Packet - Item Data Length and Packet Length Disagree.  RDL+2 ' + (reportedDataLength + 2) + ' remainingLength ' + remainingLength;
            this.outputLog(errMessage);
            this.lastError = errMessage;
            return { thePointer: 0, bufferResponse: undefined };
        }
        if (responseCode !== 0xff) {
            errMessage = 'Invalid Response Code - ' + responseCode;
            this.outputLog(errMessage);
            this.lastError = errMessage;
            return { thePointer: thePointer + reportedDataLength + 4, bufferResponse: undefined };
        }
        if (transportCode !== request.addresses[0].transportCode) {
            errMessage = 'Invalid Transport Code - ' + transportCode;
            this.outputLog(errMessage);
            this.lastError = errMessage;
            return { thePointer: thePointer + reportedDataLength + 4, bufferResponse: undefined };
        }
        var expectedLength = request.totalbyteLength;
        if (reportedDataLength !== expectedLength) {
            errMessage = 'Invalid Response Length - Expected ' + expectedLength + ' but got ' + reportedDataLength + ' bytes.';
            this.outputLog(errMessage);
            this.lastError = errMessage;
            return { thePointer: reportedDataLength + 2, bufferResponse: undefined };
        }
        // Looks good so far.
        // Increment our data pointer past the status code, transport code and 2 byte length.
        thePointer += 4;
        var bufferResponse = theData.slice(thePointer, thePointer + reportedDataLength);
        // (theData as Buffer).slice(thePointer, thePointer + reportedDataLength).copy(theItem.byteBuffer, 0);
        // theItem.qualityBuffer.fill(0xc0); // Fill with 0xC0 (192) which means GOOD QUALITY in the OPC world.
        thePointer += request.totalbyteLength; //WithFill;
        if ((thePointer - prePointer) % 2) {
            // Odd number.  With the S7 protocol we only request an even number of bytes.  So there will be a filler byte.
            thePointer += 1;
        }
        return { thePointer: thePointer, bufferResponse: bufferResponse };
    };
    S7Comm.prototype.BufferToAddressValue = function (address, buffer) {
        var thePointer = 0;
        var strlen = 0;
        var tempString = '';
        var readValue;
        var quality;
        if (address.arrayLength > 1) {
            // Array value.
            if (address.dataType != 'C' && address.dataType != 'CHAR') {
                readValue = [];
                quality = [];
            }
            else {
                readValue = '';
                quality = '';
            }
            var bitShiftAmount = address.bitOffset;
            for (var arrayIndex = 0; arrayIndex < address.arrayLength; arrayIndex++) {
                // If we're a string, quality is not an array.
                if (quality instanceof Array) {
                    quality.push('OK');
                }
                else {
                    quality = 'OK';
                }
                switch (address.dataType) {
                    case 'REAL':
                        readValue.push(buffer.readFloatBE(thePointer));
                        break;
                    case 'DWORD':
                        readValue.push(buffer.readUInt32BE(thePointer));
                        break;
                    case 'DINT':
                        readValue.push(buffer.readInt32BE(thePointer));
                        break;
                    case 'INT':
                        readValue.push(buffer.readInt16BE(thePointer));
                        break;
                    case 'WORD':
                        readValue.push(buffer.readUInt16BE(thePointer));
                        break;
                    case 'X':
                        readValue.push((buffer.readUInt8(thePointer) >> bitShiftAmount) & 1 ? true : false);
                        break;
                    case 'B':
                    case 'BYTE':
                        readValue.push(buffer.readUInt8(thePointer));
                        break;
                    case 'S':
                    case 'STRING':
                        strlen = buffer.readUInt8(thePointer + 1);
                        tempString = '';
                        for (var charOffset = 2; charOffset < address.dataTypeLength && charOffset - 2 < strlen; charOffset++) {
                            // say strlen = 1 (one-char string) this char is at arrayIndex of 2.
                            // Convert to string.
                            tempString += String.fromCharCode(buffer.readUInt8(thePointer + charOffset));
                        }
                        readValue.push(tempString);
                        break;
                    case 'C':
                    case 'CHAR':
                        // Convert to string.
                        readValue += String.fromCharCode(buffer.readUInt8(thePointer));
                        break;
                    case 'TIMER':
                    case 'COUNTER':
                        readValue.push(buffer.readInt16BE(thePointer));
                        break;
                    default:
                        this.outputLog('Unknown data type in response - should never happen.  Should have been caught earlier.  ' + address.dataType);
                        return 0;
                }
                if (address.dataType == 'X') {
                    // For bit arrays, we have to do some tricky math to get the pointer to equal the byte offset.
                    // Note that we add the bit offset here for the rare case of an array starting at other than zero.  We either have to
                    // drop support for this at the request level or support it here.
                    bitShiftAmount++;
                    if ((arrayIndex + address.bitOffset + 1) % 8 === 0 || arrayIndex == address.arrayLength - 1) {
                        thePointer += address.dataTypeLength;
                        bitShiftAmount = 0;
                    }
                }
                else {
                    // Add to the pointer every time.
                    thePointer += address.dataTypeLength;
                }
            }
        }
        else {
            // Single value.
            if (!address.valid) {
                // theItem.readValue = theItem.badValue();
                // theItem.quality = 'BAD ' + theItem.qualityBuffer[thePointer];
            }
            else {
                quality = 'OK';
                switch (address.dataType) {
                    case 'REAL':
                        readValue = buffer.readFloatBE(thePointer);
                        break;
                    case 'DWORD':
                        readValue = buffer.readUInt32BE(thePointer);
                        break;
                    case 'DINT':
                        readValue = buffer.readInt32BE(thePointer);
                        break;
                    case 'INT':
                        readValue = buffer.readInt16BE(thePointer);
                        break;
                    case 'WORD':
                        readValue = buffer.readUInt16BE(thePointer);
                        break;
                    case 'X':
                        readValue = (buffer.readUInt8(thePointer) >> address.bitOffset) & 1 ? true : false;
                        break;
                    case 'B':
                    case 'BYTE':
                        // No support as of yet for signed 8 bit.  This isn't that common in Siemens.
                        readValue = buffer.readUInt8(thePointer);
                        break;
                    case 'S':
                    case 'STRING':
                        strlen = buffer.readUInt8(thePointer + 1);
                        readValue = '';
                        // evitar desbordamineto
                        for (var charOffset = 2; charOffset < address.dataTypeLength && charOffset - 2 < strlen; charOffset++) {
                            // say strlen = 1 (one-char string) this char is at arrayIndex of 2.
                            // Convert to string.
                            readValue += String.fromCharCode(buffer.readUInt8(thePointer + charOffset));
                        }
                        break;
                    case 'C':
                    case 'CHAR':
                        // No support as of yet for signed 8 bit.  This isn't that common in Siemens.
                        readValue = String.fromCharCode(buffer.readUInt8(thePointer));
                        break;
                    case 'TIMER':
                    case 'COUNTER':
                        readValue = buffer.readInt16BE(thePointer);
                        break;
                    default:
                        this.outputLog('Unknown data type in response - should never happen.  Should have been caught earlier.  ' + address.dataType);
                        return 0;
                }
            }
            thePointer += address.dataTypeLength;
        }
        if (thePointer % 2) {
            // Odd number.  With the S7 protocol we only request an even number of bytes.  So there will be a filler byte.
            thePointer += 1;
        }
        //	outputLog("We have an item value of " + theItem.value + " for " + theItem.addr + " and pointer of " + thePointer);
        return readValue;
    };
    S7Comm.prototype.checkReadResponseParts = function (readRequestSequence) {
        for (var i = 0; i < this.sentReadPacketArray.length; i++) {
            if (this.sentReadPacketArray[i].readRequestSequence === readRequestSequence) {
                if (this.sentReadPacketArray[i].rcvd === false) {
                    return false;
                }
            }
        }
        return true;
    };
    S7Comm.prototype.checkWriteResponseParts = function (writeRequestSequence) {
        for (var i = 0; i < this.sentWritePacketArray.length; i++) {
            if (this.sentWritePacketArray[i].writeRequestSequence === writeRequestSequence) {
                if (this.sentWritePacketArray[i].rcvd === false) {
                    return false;
                }
            }
        }
        return true;
    };
    S7Comm.prototype.readResponse = function (data, foundSeqIndex) {
        var _this = this;
        this.outputLog('Read response called', 1, this.connectionId);
        // Make a note of the time it took the PLC to process the request.
        this.outputLog('Received in ' + (process.hrtime.bigint() - this.sentReadPacketArray[foundSeqIndex].reqTime) + ' nanoseconds', 0, this.connectionId);
        clearTimeout(this.sentReadPacketArray[foundSeqIndex].timeout);
        if (!this.sentReadPacketArray[foundSeqIndex].sent) {
            this.outputLog('WARNING: Received a read response packet that was not marked as sent', 0, this.connectionId);
            return;
        }
        if (this.sentReadPacketArray[foundSeqIndex].rcvd) {
            this.outputLog('WARNING: Received a read response packet that was already marked as received', 0, this.connectionId);
            return;
        }
        this.sentReadPacketArray[foundSeqIndex].rcvd = true;
        this.parallelJobsNow -= 1;
        if (this.requestQueue.length) {
            this.sendNextRequest();
        }
        var dataPointer = 21; // For non-routed packets we start at byte 21 of the packet.  If we do routing it will be more than this.
        for (var i = 0; i < this.sentReadPacketArray[foundSeqIndex].requestList.length; i++) {
            var _a = this.validateReadResponse(data, this.sentReadPacketArray[foundSeqIndex].requestList[i], dataPointer), thePointer = _a.thePointer, bufferResponse = _a.bufferResponse;
            dataPointer = thePointer;
            this.sentReadPacketArray[foundSeqIndex].requestList[i].responseBuffer = bufferResponse;
            if (!dataPointer) {
                this.outputLog('Received a ZERO RESPONSE Processing Read Packet due to unrecoverable packet error', 0, this.connectionId);
                break;
            }
        }
        var canDeletePackets = true;
        // If the sentReadPacket have only one part, we can continue to check values
        if (this.sentReadPacketArray[foundSeqIndex].requestList[0].parts === 1) {
            for (var i = 0; i < this.sentReadPacketArray[foundSeqIndex].requestList.length; i++) {
                if (typeof this.sentReadPacketArray[foundSeqIndex].requestList[i].responseBuffer !== 'undefined') {
                    var offset = 0;
                    var buffer = this.sentReadPacketArray[foundSeqIndex].requestList[i].responseBuffer.slice(offset, this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[0].byteLength + offset);
                    var value = this.BufferToAddressValue(this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[0], buffer);
                    this.outputLog('Address ' + this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[0].userName + ' has value ' + value, 1, this.connectionId);
                    var result = {};
                    result[this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[0].userName] = value;
                    this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[0].promiseResolve(result);
                    for (var u = 1; u < this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses.length; u++) {
                        var pastOffset = this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u - 1].offset;
                        var currentOffset = this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u].offset;
                        if (pastOffset !== currentOffset) {
                            offset += this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u].offset - this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u - 1].offset;
                        }
                        var buffer_1 = this.sentReadPacketArray[foundSeqIndex].requestList[i].responseBuffer.slice(offset, this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u].byteLength + offset);
                        var value_1 = this.BufferToAddressValue(this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u], buffer_1);
                        this.outputLog('Address ' + this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u].userName + ' has value ' + value_1, 1, this.connectionId);
                        var result_1 = {};
                        result_1[this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u].userName] = value_1;
                        this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[u].promiseResolve(result_1);
                    }
                }
                else {
                    for (var u = 0; u < this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses.length; u++) {
                        this.sentReadPacketArray[foundSeqIndex].requestList[i].addresses[0].promiseReject(this.lastError);
                    }
                }
            }
        }
        else if (this.sentReadPacketArray[foundSeqIndex].requestList[0].parts > 1 && this.checkReadResponseParts(this.sentReadPacketArray[foundSeqIndex].readRequestSequence)) {
            // If the sentReadPacket have two or more parts and are already received
            var validResponse = true;
            var buffer = Buffer.alloc(this.sentReadPacketArray[foundSeqIndex].requestList[0].addresses[0].dataTypeLength);
            var readRequestSequence = this.sentReadPacketArray[foundSeqIndex].requestList[0].readRequestSequence;
            for (var i = 0; i < this.sentReadPacketArray.length; i++) {
                if (this.sentReadPacketArray[i].readRequestSequence === readRequestSequence) {
                    if (typeof this.sentReadPacketArray[i].requestList[0].responseBuffer !== 'undefined') {
                        this.sentReadPacketArray[i].requestList[0].responseBuffer.copy(buffer, this.sentReadPacketArray[i].requestList[0].offset - this.sentReadPacketArray[i].requestList[0].addresses[0].offset);
                    }
                    else {
                        validResponse = false;
                    }
                }
            }
            if (validResponse) {
                var value = this.BufferToAddressValue(this.sentReadPacketArray[foundSeqIndex].requestList[0].addresses[0], buffer);
                this.outputLog('Address ' + this.sentReadPacketArray[foundSeqIndex].requestList[0].addresses[0].userName + ' has value ' + value, 1, this.connectionId);
                var result = {};
                result[this.sentReadPacketArray[foundSeqIndex].requestList[0].addresses[0].userName] = value;
                this.sentReadPacketArray[foundSeqIndex].requestList[0].addresses[0].promiseResolve(result);
            }
            else {
                this.sentReadPacketArray[foundSeqIndex].requestList[0].addresses[0].promiseReject();
            }
        }
        else {
            // we must wait until other parts comming for check
            this.outputLog('Wait for parts of read request part' + this.sentReadPacketArray[foundSeqIndex].readRequestSequence, 1, this.connectionId);
            canDeletePackets = false;
        }
        if (canDeletePackets) {
            this.sentReadPacketArray = this.sentReadPacketArray.filter(function (packet) {
                return packet.readRequestSequence !== _this.sentReadPacketArray[foundSeqIndex].readRequestSequence;
            });
        }
        // If a response was whit timeout exceeded, the connectionState change to 'disconnected'
        if (this.isoConnectionState === 'disconnected') {
            // Reject all pending requests
            this.rejectAllRequestQueue();
            // reconnect
            this.connectionReset();
        }
    };
    S7Comm.prototype.writeResponse = function (data, foundSeqIndex) {
        var _this = this;
        this.outputLog('Write response called', 1, this.connectionId);
        // Make a note of the time it took the PLC to process the request.
        this.outputLog('Received in ' + (process.hrtime.bigint() - this.sentWritePacketArray[foundSeqIndex].reqTime) + ' nanoseconds', 0, this.connectionId);
        clearTimeout(this.sentWritePacketArray[foundSeqIndex].timeout);
        this.sentWritePacketArray[foundSeqIndex].rcvd = true;
        this.parallelJobsNow -= 1;
        if (this.requestQueue.length) {
            this.sendNextRequest();
        }
        var dataPointer = 21;
        for (var itemCount = 0; itemCount < this.sentWritePacketArray[foundSeqIndex].requestList.length; itemCount++) {
            dataPointer = this.validateWriteResponse(data, this.sentWritePacketArray[foundSeqIndex].requestList[itemCount].itemReference, dataPointer);
            if (!dataPointer) {
                this.outputLog('Stopping Processing Write Response Packet due to unrecoverable packet error');
                break;
            }
        }
        var canDeletePackets = true;
        // If the sentReadPacket have only one part, we can continue to check values
        if (this.sentWritePacketArray[foundSeqIndex].requestList[0].parts === 1) {
            for (var i = 0; i < this.sentWritePacketArray[foundSeqIndex].requestList.length; i++) {
                this.outputLog(this.sentWritePacketArray[foundSeqIndex].requestList[i].itemReference.address.name + ' write completed with quality ' + this.sentWritePacketArray[foundSeqIndex].requestList[i].itemReference.validResponseBuffer, 1, this.connectionId);
                if (this.sentWritePacketArray[foundSeqIndex].requestList[i].itemReference.validResponseBuffer) {
                    var result = {};
                    result[this.sentWritePacketArray[foundSeqIndex].requestList[i].itemReference.address.userName] = this.sentWritePacketArray[foundSeqIndex].requestList[i].itemReference.writeValue;
                    this.sentWritePacketArray[foundSeqIndex].requestList[i].itemReference.address.promiseResolve(result);
                }
                else {
                    this.sentWritePacketArray[foundSeqIndex].requestList[i].itemReference.address.promiseReject();
                }
            }
        }
        else if (this.sentWritePacketArray[foundSeqIndex].requestList[0].parts > 1 && this.checkWriteResponseParts(this.sentWritePacketArray[foundSeqIndex].writeRequestSequence)) {
            // If the sentReadPacket have two or more parts and are already received
            var validResponse = true;
            var writeRequestSequence = this.sentWritePacketArray[foundSeqIndex].requestList[0].writeRequestSequence;
            for (var i = 0; i < this.sentWritePacketArray.length; i++) {
                if (this.sentWritePacketArray[i].writeRequestSequence === writeRequestSequence) {
                    this.outputLog(this.sentWritePacketArray[i].requestList[0].itemReference.address.name + ' write completed with quality ' + this.sentWritePacketArray[i].requestList[0].itemReference.validResponseBuffer, 1, this.connectionId);
                    validResponse = this.sentWritePacketArray[i].requestList[0].itemReference.validResponseBuffer;
                }
            }
            if (validResponse) {
                var result = {};
                result[this.sentWritePacketArray[foundSeqIndex].requestList[0].itemReference.address.userName] = this.sentWritePacketArray[foundSeqIndex].requestList[0].itemReference.writeValue;
                this.sentWritePacketArray[foundSeqIndex].requestList[0].itemReference.address.promiseResolve(result);
            }
            else {
                this.sentWritePacketArray[foundSeqIndex].requestList[0].itemReference.address.promiseReject();
            }
        }
        else {
            // we must wait until other parts comming for check
            this.outputLog('Wait for parts of write request part ' + this.sentWritePacketArray[foundSeqIndex].writeRequestSequence, 0, this.connectionId);
            canDeletePackets = false;
        }
        if (canDeletePackets) {
            this.sentWritePacketArray = this.sentWritePacketArray.filter(function (packet) {
                return packet.writeRequestSequence !== _this.sentWritePacketArray[foundSeqIndex].writeRequestSequence;
            });
        }
        // If a response was whit timeout exceeded, the connectionState change to 'disconnected'
        if (this.isoConnectionState === 'disconnected') {
            // Reject all pending requests
            this.rejectAllRequestQueue();
            // reconnect
            this.connectionReset();
        }
    };
    S7Comm.prototype.checkRfcData = function (data) {
        var ret;
        var rfcVersion = data[0];
        var tpktLength = data.readInt16BE(2);
        var tpduCode = data[5]; //Data==0xF0 !!
        var LastDataUnit = data[6]; //empty fragmented frame => 0=not the last package; 1=last package
        if (rfcVersion !== 0x03 && tpduCode !== 0xf0) {
            //Check if its an RFC package and a Data package
            return 'error';
        }
        else if (LastDataUnit >> 7 === 0 && tpktLength == data.length && data.length === 7) {
            // Check if its a Fast Acknowledge package from older PLCs or  WinAC or data is too long ...
            // For example: <Buffer 03 00 00 07 02 f0 00> => data.length==7
            ret = 'fastACK';
        }
        else if (LastDataUnit >> 7 == 1 && tpktLength <= data.length) {
            // Check if its an  FastAcknowledge package + S7Data package
            // <Buffer 03 00 00 1b 02 f0 80 32 03 00 00 00 00 00 08 00 00 00 00 f0 00 00 01 00 01 00 f0> => data.length==7+20=27
            ret = data;
        }
        else if (LastDataUnit >> 7 == 0 && tpktLength !== data.length) {
            // Check if its an  FastAcknowledge package + FastAcknowledge package+ S7Data package
            // Possibly because NodeS7 or Application is too slow at this moment!
            // <Buffer 03 00 00 07 02 f0 00 03 00 00 1b 02 f0 80 32 03 00 00 00 00 00 08 00 00 00 00 f0 00 00 01 00 01 00 f0>  => data.length==7+7+20=34
            ret = data.slice(7, data.length); //Cut off the first Fast Acknowledge Packet
        }
        else {
            ret = 'error';
        }
        return ret;
    };
    S7Comm.prototype.onPDUReply = function (theData) {
        var _this = this;
        this.client.removeAllListeners('error');
        clearTimeout(this.PDUTimeout);
        var data = this.checkRfcData(theData);
        if (data === 'fastACK') {
            //Read again and wait for the requested data
            this.outputLog('Fast Acknowledge received.', 0, this.connectionId);
            this.client.removeAllListeners('error');
            this.client.removeAllListeners('data');
            this.client.once('data', function (data) {
                _this.onPDUReply(data);
            });
            this.client.on('error', function (err) {
                console.log(err);
                _this.readWriteError(new Error('Error on PDURefly'));
            });
        }
        else if (data instanceof Buffer && data[4] + 1 + 12 + data.readInt16BE(13) === data.readInt16BE(2) - 4) {
            //valid the length of FA+S7 package :  ISO_Length+ISO_LengthItself+S7Com_Header+S7Com_Header_ParameterLength===TPKT_Length-4
            //Everything OK...go on
            // Track the connection state
            this.isoConnectionState = 's7comm'; // Received PDU response, good to go
            var partnerMaxParallel1 = data.readInt16BE(21);
            var partnerMaxParallel2 = data.readInt16BE(23);
            var partnerPDU = data.readInt16BE(25);
            this.maxParallel = this.requestMaxParallel;
            if (partnerMaxParallel1 < this.requestMaxParallel) {
                this.maxParallel = partnerMaxParallel1;
            }
            if (partnerMaxParallel2 < this.requestMaxParallel) {
                this.maxParallel = partnerMaxParallel2;
            }
            if (partnerPDU < this.requestMaxPDU) {
                this.maxPDU = partnerPDU;
            }
            else {
                this.maxPDU = this.requestMaxPDU;
            }
            this.outputLog('Received PDU Response - Proceeding with PDU ' + this.maxPDU + ' and ' + this.maxParallel + ' max parallel connections.', 0, this.connectionId);
            this.client.on('data', function (data) {
                _this.onResponse(data);
            });
            this.client.on('error', function () {
                _this.readWriteError(new Error('Error on client 2, onPDUReply function'));
            });
            if (!this.connectCBIssued && typeof this.connectCallback === 'function') {
                this.connectCBIssued = true;
                this.connectCallback();
            }
        }
        else {
            this.outputLog('INVALID Telegram ', 0, this.connectionId);
            this.outputLog('Byte 0 From Header is ' + theData[0] + ' it has to be 0x03, Byte 5 From Header is  ' + theData[5] + ' and it has to be 0x0F ', 0, this.connectionId);
            this.outputLog('INVALID PDU RESPONSE or CONNECTION REFUSED - DISCONNECTING', 0, this.connectionId);
            this.outputLog('TPKT Length From Header is ' + theData.readInt16BE(2) + ' and RCV buffer length is ' + theData.length + ' and COTP length is ' + theData.readUInt8(4) + ' and data[6] is ' + theData[6], 0, this.connectionId);
            this.outputLog(theData);
            var timeHandler = function () {
                _this.connectionReset();
            };
            this.client.destroy();
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = setTimeout(timeHandler, 2000);
        }
    };
    S7Comm.prototype.onResponse = function (theData) {
        // Packet Validity Check.  Note that this will pass even with a "not available" response received from the server.
        // For length calculation and verification:
        // data[4] = COTP header length. Normally 2.  This doesn't include the length byte so add 1.
        // read(13) is parameter length.  Normally 4.
        // read(14) is data length.  (Includes item headers)
        // 12 is length of "S7 header"
        // Then we need to add 4 for TPKT header.
        var _this = this;
        if (!(theData && theData.length > 6)) {
            this.outputLog('INVALID READ RESPONSE - DISCONNECTING');
            this.outputLog("The incoming packet doesn't have the required minimum length of 7 bytes");
            this.outputLog(theData);
            return;
        }
        var data = this.checkRfcData(theData);
        if (data === 'fastACK') {
            //read again and wait for the requested data
            this.outputLog('Fast Acknowledge received.', 0, this.connectionId);
            this.client.removeAllListeners('error');
            this.client.removeAllListeners('data');
            this.client.on('data', function (data) {
                _this.onResponse(data);
            });
            this.client.on('error', function () {
                _this.readWriteError(new Error('Error onisoclient, onReadResponse1'));
            });
        }
        else if (data instanceof Buffer && data[7] === 0x32) {
            //check the validy of FA+S7 package
            //*********************   VALIDY CHECK ***********************************
            //TODO: Check S7-Header properly
            if (data.length > 8 && data[8] != 3) {
                this.outputLog('PDU type (byte 8) was returned as ' + data[8] + ' where the response PDU of 3 was expected.');
                this.outputLog('Maybe you are requesting more than 240 bytes of data in a packet?');
                this.outputLog(data);
                this.connectionReset();
                return;
            }
            // The smallest read packet will pass a length check of 25.  For a 1-item write response with no data, length will be 22.
            if (data.length > data.readInt16BE(2)) {
                this.outputLog('An oversize packet was detected.  Excess length is ' + (data.length - data.readInt16BE(2)) + '.  ');
                this.outputLog('We assume this is because two packets were sent at nearly the same time by the PLC.');
                this.outputLog('We are slicing the buffer and scheduling the second half for further processing next loop.');
                setTimeout(function () {
                    _this.onResponse(data.slice(data.readInt16BE(2)));
                }, 0); // This re-triggers this same function with the sliced-up buffer.
            }
            if (data.length < data.readInt16BE(2) || data.readInt16BE(2) < 22 || data[5] !== 0xf0 || data[4] + 1 + 12 + 4 + data.readInt16BE(13) + data.readInt16BE(15) !== data.readInt16BE(2) || !(data[6] >> 7) || data[7] !== 0x32 || data[8] !== 3) {
                this.outputLog('INVALID READ RESPONSE - DISCONNECTING');
                this.outputLog('TPKT Length From Header is ' + data.readInt16BE(2) + ' and RCV buffer length is ' + data.length + ' and COTP length is ' + data.readUInt8(4) + ' and data[6] is ' + data[6]);
                this.outputLog(data);
                this.connectionReset();
                return;
            }
            //**********************   GO ON  *************************
            // Log the receive
            this.outputLog('Received ' + data.readUInt16BE(15) + ' bytes of S7-data from PLC.  Sequence number is ' + data.readUInt16BE(11), 0, this.connectionId);
            // Check the sequence number
            var foundSeqNum = undefined;
            var isReadResponse = false;
            var isWriteResponse = false;
            if (data[19] === 0x05) {
                // write response
                foundSeqNum = this.findWriteIndexOfSeqNum(data.readUInt16BE(11));
                if (typeof foundSeqNum !== 'undefined') {
                    this.writeResponse(data, foundSeqNum);
                    isWriteResponse = true;
                }
            }
            else if (data[19] === 0x04) {
                // read response
                foundSeqNum = this.findReadIndexOfSeqNum(data.readUInt16BE(11));
                if (typeof foundSeqNum !== 'undefined') {
                    this.readResponse(data, foundSeqNum);
                    isReadResponse = true;
                }
            }
            if (!isReadResponse && !isWriteResponse) {
                this.outputLog("Sequence number that arrived wasn't a write reply either - dropping");
                this.outputLog(data);
                return;
            }
        }
        else {
            this.outputLog('INVALID READ RESPONSE - DISCONNECTING');
            this.outputLog('TPKT Length From Header is ' + theData.readInt16BE(2) + ' and RCV buffer length is ' + theData.length + ' and COTP length is ' + theData.readUInt8(4) + ' and data[6] is ' + theData[6]);
            this.outputLog(theData);
            this.connectionReset();
            return;
        }
    };
    S7Comm.prototype.onISOConnectReply = function (data) {
        var _this = this;
        this.client.removeAllListeners('error');
        clearTimeout(this.connectTimeout);
        // ignore if we're not expecting it - prevents write after end exception as of #80
        if (this.isoConnectionState != 'tcp') {
            this.outputLog('Ignoring ISO connect reply, expecting isoConnectionState of 2, is currently ' + this.isoConnectionState, 0, this.connectionId);
            return;
        }
        // Track the connection state
        this.isoConnectionState = 'isoOnTcp'; // ISO-ON-TCP connected, Wait for PDU response.
        // Expected length is from packet sniffing - some applications may be different, especially using routing - not considered yet.
        if (data.readInt16BE(2) !== data.length || data.length < 22 || data[5] !== 0xd0 || data[4] !== data.length - 5) {
            this.outputLog('INVALID PACKET or CONNECTION REFUSED - DISCONNECTING');
            this.outputLog(data);
            this.outputLog('TPKT Length From Header is ' + data.readInt16BE(2) + ' and RCV buffer length is ' + data.length + ' and COTP length is ' + data.readUInt8(4) + ' and data[5] is ' + data[5]);
            this.connectionReset();
            return;
        }
        this.outputLog('ISO-on-TCP Connection Confirm Packet Received', 0, this.connectionId);
        this.negotiatePDU.writeInt16BE(this.requestMaxParallel, 19);
        this.negotiatePDU.writeInt16BE(this.requestMaxParallel, 21);
        this.negotiatePDU.writeInt16BE(this.requestMaxPDU, 23);
        var timeHandler = function () {
            _this.packetTimeout('PDU');
        };
        this.PDUTimeout = setTimeout(timeHandler, this.globalTimeout);
        this.client.once('data', function (data) {
            _this.onPDUReply(data);
        });
        this.client.on('error', function (err) {
            console.log(err);
            _this.readWriteError(new Error('Error on ISO Reply'));
        });
        this.client.write(this.negotiatePDU.slice(0, 25));
    };
    S7Comm.prototype.onTCPConnect = function () {
        var _this = this;
        this.outputLog('TCP Connection Established to ' + this.client.remoteAddress + ' on port ' + this.client.remotePort, 0, this.connectionId);
        this.outputLog('Will attempt ISO-on-TCP connection', 0, this.connectionId);
        // Track the connection state
        this.isoConnectionState = 'tcp'; // 2 = TCP connected, wait for ISO connection confirmation
        // Send an ISO-on-TCP connection request.
        var timeHandler = function () {
            _this.packetTimeout('ISO');
        };
        this.connectTimeout = setTimeout(timeHandler, this.globalTimeout);
        var connBuf = this.connectReq;
        if (this.localTSAP !== undefined && this.remoteTSAP !== undefined) {
            this.outputLog('Using localTSAP [0x' + this.localTSAP.toString(16) + '] and remoteTSAP [0x' + this.remoteTSAP.toString(16) + ']', 0, this.connectionId);
            connBuf.writeUInt16BE(this.localTSAP, 16);
            connBuf.writeUInt16BE(this.remoteTSAP, 20);
        }
        else {
            this.outputLog('Using rack [' + this.rack + '] and slot [' + this.slot + ']', 0, this.connectionId);
            connBuf[21] = this.rack * 32 + this.slot;
        }
        // Listen for a reply.
        this.client.once('data', function (data) {
            _this.onISOConnectReply(data);
        });
        // // Hook up the event that fires on disconnect
        this.client.on('end', function () {
            console.log('end');
            // this.onClientDisconnect();
        });
        // listen for close (caused by us sending an end or caused by timeout socket)
        this.client.on('close', function (hasError) {
            if (hasError) {
                _this.outputLog('Connection has been closed due to a connection error or inactivity');
                _this.connectionReset();
            }
        });
        this.client.on('error', function (err) {
            console.log('error');
            _this.connectionReset();
            console.log(err);
        });
        this.client.write(connBuf);
    };
    S7Comm.prototype.connectNow = function () {
        var _this = this;
        // prevents any reconnect timer to fire this again
        clearTimeout(this.reconnectTimer);
        // Don't re-trigger.
        if (this.isoConnectionState !== 'disconnected') {
            return;
        }
        this.connectionCleanup();
        this.client = new net_1.Socket();
        this.client = net_1.connect({
            port: this.ConnectionConfig.port,
            host: this.ConnectionConfig.host,
        });
        this.client.setTimeout(this.ConnectionConfig.timeout || 5000, function () {
            _this.client.destroy();
            _this.connectError(new Error('Error connecting - destroying connection'));
        });
        this.client.once('connect', function () {
            _this.client.setTimeout(0);
            _this.onTCPConnect();
        });
        this.client.on('error', function (err) {
            console.log(err);
            _this.client.destroy();
            _this.connectError(new Error('Something went wrong trying to connect'));
        });
        this.outputLog('Attempting to connect to host...', 0, this.connectionId);
    };
    S7Comm.prototype.sendNextRequest = function () {
        var _this = this;
        var request = this.requestQueue.shift();
        if (request.action === 'read') {
            setTimeout(function () {
                _this.sendReadPacket([request.request]);
            }, 0);
        }
        else if (request.action === 'write') {
            setTimeout(function () {
                _this.sendWritePacket([request.request]);
            }, 0);
        }
    };
    S7Comm.prototype.prepareReadPacket = function (addresses) {
        // Note that for a PDU size of 240, the MOST bytes we can request depends on the number of items.
        // To figure this out, allow for a 247 byte packet.  7 TPKT+COTP header doesn't count for PDU, so 240 bytes of "S7 data".
        // In the response you ALWAYS have a 12 byte S7 header.
        // Then you have a 2 byte parameter header.
        // Then you have a 4 byte "item header" PER ITEM.
        // So you have overhead of 18 bytes for one item, 22 bytes for two items, 26 bytes for 3 and so on.  So for example you can request 240 - 22 = 218 bytes for two items.
        // We can calculate a max byte length for single request as 4*Math.floor((self.maxPDU - 18)/4) - to ensure we don't cross boundaries.
        var addressesToRead = addresses; // Address requested by the user
        // Sort the items using the sort function, by type and offset.
        addressesToRead.sort(this.addressListSorter);
        var readBlockList = [];
        readBlockList.push({
            totalbyteLength: addressesToRead[0].byteLength,
            offset: addressesToRead[0].offset,
            byteLengthWithFill: addressesToRead[0].byteLengthWithFill,
            addresses: [],
            isOptimized: true,
        });
        readBlockList[0].addresses.push(addressesToRead[0]);
        var thisBlock = 0;
        var maxByteRequest = 4 * Math.floor((this.maxPDU - 18) / 4); // Absolutely must not break a real array into two requests.  Maybe we can extend by two bytes when not DINT/REAL/INT.
        // Optimize the items into blocks
        for (var i = 1; i < addressesToRead.length; i++) {
            //     // Skip T, C, P types
            if (addressesToRead[i].areaS7Code !== readBlockList[thisBlock].addresses[0].areaS7Code || // Can't optimize between areas
                addressesToRead[i].dbNumber !== readBlockList[thisBlock].addresses[0].dbNumber || // Can't optimize across DBs
                !this.isOptimizableArea(addressesToRead[i].areaS7Code) || // Can't optimize T,C (I don't think) and definitely not P.
                addressesToRead[i].offset - readBlockList[thisBlock].addresses[0].offset + addressesToRead[i].byteLength > maxByteRequest || // If this request puts us over our max byte length, create a new block for consistency reasons.
                addressesToRead[i].offset - (readBlockList[thisBlock].addresses[0].offset + readBlockList[thisBlock].addresses[0].byteLength) > this.maxGap) {
                // If our gap is large, create a new block.
                this.outputLog('Skipping optimization of item ' + addressesToRead[i].name, 0, this.connectionId);
                // At this point we give up and create a new block.
                readBlockList.push({
                    totalbyteLength: addressesToRead[i].byteLength,
                    byteLengthWithFill: addressesToRead[i].byteLengthWithFill,
                    offset: addressesToRead[i].offset,
                    addresses: [addressesToRead[i]],
                    isOptimized: false,
                });
                thisBlock = thisBlock + 1;
                // globalReadBlockList[thisBlock].itemReference = itemList[i]; // By reference.
            }
            else {
                this.outputLog('Attempting optimization of item ' + addressesToRead[i].name + '  ' + thisBlock + ' with ' + readBlockList[thisBlock].addresses[0].name, 0, this.connectionId);
                // This next line checks the maximum.
                // Think of this situation - we have a large request of 40 bytes starting at byte 10.
                //	Then someone else wants one byte starting at byte 12.  The block length doesn't change.
                //
                // But if we had 40 bytes starting at byte 10 (which gives us byte 10-49) and we want byte 50, our byte length is 50-10 + 1 = 41.
                readBlockList[thisBlock].totalbyteLength = Math.max(readBlockList[thisBlock].totalbyteLength, addressesToRead[i].offset - readBlockList[thisBlock].addresses[0].offset + addressesToRead[i].byteLength);
                // Point the buffers (byte and quality) to a sliced version of the optimized block.  This is by reference (same area of memory)
                readBlockList[thisBlock].isOptimized = true;
                readBlockList[thisBlock].addresses.push(addressesToRead[i]);
            }
        }
        var thisRequest = 0;
        var requestList = []; // The request list consists of the block list, split into chunks readable by PDU.
        //	outputLog("Preparing the read packet...");
        // Split the blocks into requests, if they're too large.
        for (var i = 0; i < readBlockList.length; i++) {
            // How many parts?
            var parts = Math.ceil(readBlockList[i].totalbyteLength / maxByteRequest);
            this.outputLog('globalReadBlockList ' + i + ' parts is ' + parts + ' offset is ' + readBlockList[i].addresses[0].offset + ' MBR is ' + maxByteRequest, 1, this.connectionId);
            this.readRequestSequence += 1;
            if (this.readRequestSequence > 32767) {
                this.readRequestSequence = 1;
            }
            var startByte = readBlockList[i].addresses[0].offset;
            var remainingLength = readBlockList[i].totalbyteLength;
            // // If we're optimized...
            for (var j = 0; j < parts; j++) {
                requestList[thisRequest] = {
                    parts: parts,
                    addresses: readBlockList[i].addresses.map(function (address) { return (__assign({}, address)); }),
                    totalbyteLength: readBlockList[i].totalbyteLength,
                    byteLengthWithFill: readBlockList[i].byteLengthWithFill,
                    offset: readBlockList[i].offset,
                    isOptimized: readBlockList[i].isOptimized,
                    readRequestSequence: this.readRequestSequence,
                };
                requestList[thisRequest].offset = startByte;
                requestList[thisRequest].totalbyteLength = Math.min(maxByteRequest, remainingLength);
                requestList[thisRequest].byteLengthWithFill = requestList[thisRequest].totalbyteLength;
                if (requestList[thisRequest].byteLengthWithFill % 2) {
                    requestList[thisRequest].byteLengthWithFill += 1;
                }
                remainingLength -= maxByteRequest;
                thisRequest++;
                startByte += maxByteRequest;
            }
        }
        // The packetizer...
        var requestNumber = 0;
        var readPacketArray = [];
        while (requestNumber < requestList.length) {
            // Set up the read packet
            this.masterSequenceNumber += 1;
            if (this.masterSequenceNumber > 32767) {
                this.masterSequenceNumber = 1;
            }
            var numItems = 0;
            this.readReqHeader.copy(this.readReq, 0);
            // Packet's expected reply length
            var packetReplyLength = 12 + 2; //
            var packetRequestLength = 12; //s7 header and parameter header
            readPacketArray.push({
                seqNum: 0,
                requestList: [],
                readRequestSequence: 0,
            });
            var thisPacketNumber = readPacketArray.length - 1;
            readPacketArray[thisPacketNumber].seqNum = this.masterSequenceNumber;
            this.outputLog('Sequence Number is ' + readPacketArray[thisPacketNumber].seqNum, 0, this.connectionId);
            for (var i = requestNumber; i < requestList.length; i++) {
                //outputLog("Number is " + (requestList[i].byteLengthWithFill + 4 + packetReplyLength));
                if (requestList[i].byteLengthWithFill + 4 + packetReplyLength > this.maxPDU || packetRequestLength + 12 > this.maxPDU) {
                    this.outputLog('Splitting request: ' + numItems + ' items, requestLength would be ' + (packetRequestLength + 12) + ', replyLength would be ' + (requestList[i].byteLengthWithFill + 4 + packetReplyLength) + ', PDU is ' + this.maxPDU, 0, this.connectionId);
                    if (numItems === 0) {
                        this.outputLog("breaking when we shouldn't, rlibl " + requestList[i].byteLengthWithFill + ' MBR ' + maxByteRequest, 0, this.connectionId);
                        throw new Error("Somehow write request didn't split properly - exiting.  Report this as a bug.");
                    }
                    break; // We can't fit this packet in here.
                }
                requestNumber++;
                numItems++;
                packetReplyLength += requestList[i].byteLengthWithFill + 4;
                packetRequestLength += 12;
                readPacketArray[thisPacketNumber].requestList.push(requestList[i]);
                readPacketArray[thisPacketNumber].readRequestSequence = requestList[i].readRequestSequence;
            }
        }
        return readPacketArray;
    };
    S7Comm.prototype.sendReadPacket = function (readPacketArray) {
        var _this = this;
        this.outputLog('SendReadPacket called', 1, this.connectionId);
        var _loop_1 = function (i) {
            // If our parallels jobs is on top, we are pushing into the queue
            if (this_1.parallelJobsNow >= this_1.maxParallel) {
                this_1.requestQueue.push({
                    request: readPacketArray[i],
                    action: 'read',
                });
                return "continue";
            }
            // From here down is SENDING the packet
            this_1.readReq.writeUInt8(readPacketArray[i].requestList.length, 18);
            this_1.readReq.writeUInt16BE(19 + readPacketArray[i].requestList.length * 12, 2); // buffer length
            this_1.readReq.writeUInt16BE(readPacketArray[i].seqNum, 11);
            this_1.readReq.writeUInt16BE(readPacketArray[i].requestList.length * 12 + 2, 13); // Parameter length - 14 for one read, 28 for 2.
            for (var j = 0; j < readPacketArray[i].requestList.length; j++) {
                this_1.S7AddrToBuffer(readPacketArray[i].requestList[j].addresses[0], readPacketArray[i].requestList[j].totalbyteLength, readPacketArray[i].requestList[j].byteLengthWithFill, readPacketArray[i].requestList[j].offset, false).copy(this_1.readReq, 19 + j * 12);
            }
            if (this_1.isoConnectionState === 's7comm') {
                var timeHandler = function () {
                    _this.packetTimeout('read', readPacketArray[i].seqNum);
                };
                this_1.sentReadPacketArray.push({
                    requestList: readPacketArray[i].requestList,
                    sent: true,
                    rcvd: false,
                    responseBuffer: Buffer.alloc(8192),
                    seqNum: readPacketArray[i].seqNum,
                    readRequestSequence: readPacketArray[i].readRequestSequence,
                    timeout: setTimeout(timeHandler, this_1.globalTimeout),
                    reqTime: process.hrtime.bigint(),
                });
                this_1.parallelJobsNow += 1;
                this_1.client.write(this_1.readReq.slice(0, 19 + readPacketArray[i].requestList.length * 12));
            }
            else {
                var timeHandler = function () {
                    _this.packetTimeout('read', readPacketArray[i].seqNum);
                };
                this_1.sentReadPacketArray.push({
                    requestList: readPacketArray[i].requestList,
                    sent: true,
                    rcvd: false,
                    responseBuffer: Buffer.alloc(8192),
                    seqNum: readPacketArray[i].seqNum,
                    readRequestSequence: readPacketArray[i].readRequestSequence,
                    timeout: setTimeout(timeHandler, this_1.globalTimeout),
                    reqTime: process.hrtime.bigint(),
                });
            }
            this_1.outputLog('Sending Read Packet', 1, this_1.connectionId);
        };
        var this_1 = this;
        for (var i = 0; i < readPacketArray.length; i++) {
            _loop_1(i);
        }
    };
    S7Comm.prototype.prepareWritePacket = function (instantWriteBlockList) {
        var itemList = instantWriteBlockList;
        itemList.sort(this.itemListSorter);
        var maxByteRequest = 4 * Math.floor((this.maxPDU - 18 - 12) / 4); // Absolutely must not break a real array into two requests.  Maybe we can extend by two bytes when not DINT/REAL/INT.
        var thisRequest = 0;
        var requestList = [];
        // Split the blocks into requests, if they're too large.
        for (var i = 0; i < itemList.length; i++) {
            var startByte = itemList[i].address.offset;
            var remainingLength = itemList[i].address.byteLength;
            var lengthOffset = 0;
            // How many parts?
            var parts = Math.ceil(itemList[i].address.byteLength / maxByteRequest);
            this.writeRequestSequence += 1;
            if (this.writeRequestSequence > 32767) {
                this.writeRequestSequence = 1;
            }
            for (var j = 0; j < parts; j++) {
                var s7WriteItem = this.S7ItemWrite;
                s7WriteItem.address = __assign({}, itemList[i].address); // We need a copy of values, not a reference
                s7WriteItem.writeValue = itemList[i].writeValue;
                requestList.push({
                    itemReference: s7WriteItem,
                    isOptimized: false,
                    parts: parts,
                    writeRequestSequence: this.writeRequestSequence,
                });
                requestList[thisRequest].itemReference.address.offset = startByte;
                requestList[thisRequest].itemReference.address.byteLength = Math.min(maxByteRequest, remainingLength);
                requestList[thisRequest].itemReference.address.byteLengthWithFill = requestList[thisRequest].itemReference.address.byteLength;
                if (requestList[thisRequest].itemReference.address.byteLengthWithFill % 2) {
                    requestList[thisRequest].itemReference.address.byteLengthWithFill += 1;
                }
                // Now we convert our value to a buffer
                var writeBuffer = this.bufferizeValue(itemList[i].address, itemList[i].writeValue);
                requestList[thisRequest].itemReference.writeBuffer = Buffer.from(writeBuffer.buffer, lengthOffset, lengthOffset + requestList[thisRequest].itemReference.address.byteLengthWithFill);
                lengthOffset += requestList[thisRequest].itemReference.address.byteLength;
                remainingLength -= maxByteRequest;
                thisRequest++;
                startByte += maxByteRequest;
            }
        }
        var writePacketArray = [];
        // The packetizer...
        var requestNumber = 0;
        while (requestNumber < requestList.length) {
            // Yes this is the same master sequence number shared with the read queue
            this.masterSequenceNumber += 1;
            if (this.masterSequenceNumber > 32767) {
                this.masterSequenceNumber = 1;
            }
            var numItems = 0;
            // Maybe this shouldn't really be here?
            this.writeReqHeader.copy(this.writeReq);
            // Packet's length
            var packetWriteLength = 10 + 4; // 10 byte header and 4 byte param header
            writePacketArray.push({
                requestList: [],
                seqNum: 0,
                writeRequestSequence: 0,
            });
            var thisPacketNumber = writePacketArray.length - 1;
            writePacketArray[thisPacketNumber].seqNum = this.masterSequenceNumber;
            // this.outputLog('Write Sequence Number is ' + writePacketArray[thisPacketNumber].seqNum);
            writePacketArray[thisPacketNumber].requestList = []; // Initialize as array.
            for (var i = requestNumber; i < requestList.length; i++) {
                // this.outputLog('Number is ' + (requestList[i].itemReference.address.byteLengthWithFill + 4 + packetWriteLength));
                if (requestList[i].itemReference.address.byteLengthWithFill + 12 + 4 + packetWriteLength > this.maxPDU) {
                    // 12 byte header for each item and 4 bytes for the data header
                    if (numItems === 0) {
                        this.outputLog('breaking when we shouldnt, byte length with fill is  ' + requestList[i].itemReference.address.byteLengthWithFill + ' max byte request ' + maxByteRequest, 0, this.connectionId);
                        this.lastError = 'Somehow write request didnt split properly - exiting.  Report this as a bug.';
                        throw new Error(this.lastError);
                    }
                    break; // We can't fit this packet in here.
                }
                requestNumber++;
                numItems++;
                packetWriteLength += requestList[i].itemReference.address.byteLengthWithFill + 12 + 4; // Don't forget each request has a 12 byte header as well.
                writePacketArray[thisPacketNumber].requestList.push(requestList[i]);
                writePacketArray[thisPacketNumber].writeRequestSequence = requestList[i].writeRequestSequence;
            }
        }
        return writePacketArray;
    };
    S7Comm.prototype.sendWritePacket = function (writePacketArray) {
        var _this = this;
        var itemBuffer, dataBufferPointer;
        var dataBuffer = Buffer.alloc(8192);
        var _loop_2 = function (i) {
            // If our parallels jobs is on top, we are pushing into the queue
            if (this_2.parallelJobsNow >= this_2.maxParallel) {
                this_2.requestQueue.push({
                    request: writePacketArray[i],
                    action: 'write',
                });
                return "continue";
            }
            // From here down is SENDING the packet
            this_2.writeReq.writeUInt8(writePacketArray[i].requestList.length, 18);
            this_2.writeReq.writeUInt16BE(writePacketArray[i].seqNum, 11);
            dataBufferPointer = 0;
            for (var j = 0; j < writePacketArray[i].requestList.length; j++) {
                this_2.S7AddrToBuffer(writePacketArray[i].requestList[j].itemReference.address, writePacketArray[i].requestList[j].itemReference.address.byteLength, writePacketArray[i].requestList[j].itemReference.address.byteLengthWithFill, writePacketArray[i].requestList[j].itemReference.address.offset, true).copy(this_2.writeReq, 19 + j * 12);
                itemBuffer = this_2.getWriteBuffer(writePacketArray[i].requestList[j].itemReference);
                itemBuffer.copy(dataBuffer, dataBufferPointer);
                dataBufferPointer += itemBuffer.length;
                // NOTE: It seems that when writing, the data that is sent must have a "fill byte" so that data length is even only for all
                //  but the last request.  The last request must have no padding.  So we add the padding here.
                if (j < writePacketArray[i].requestList.length - 1) {
                    if (itemBuffer.length % 2) {
                        dataBufferPointer += 1;
                    }
                }
            }
            this_2.writeReq.writeUInt16BE(19 + writePacketArray[i].requestList.length * 12 + dataBufferPointer, 2); // buffer length
            this_2.writeReq.writeUInt16BE(writePacketArray[i].requestList.length * 12 + 2, 13); // Parameter length - 14 for one read, 28 for 2.
            this_2.writeReq.writeUInt16BE(dataBufferPointer, 15); // Data length - as appropriate.
            dataBuffer.copy(this_2.writeReq, 19 + writePacketArray[i].requestList.length * 12, 0, dataBufferPointer);
            if (this_2.isoConnectionState === 's7comm') {
                // this.outputLog('writing' + (19 + dataBufferPointer + writePacketArray[i].requestList.length * 12));
                var timeHandler = function () {
                    _this.packetTimeout('write', writePacketArray[i].seqNum);
                };
                this_2.sentWritePacketArray.push({
                    requestList: writePacketArray[i].requestList,
                    sent: true,
                    rcvd: false,
                    seqNum: writePacketArray[i].seqNum,
                    timeout: setTimeout(timeHandler, this_2.globalTimeout),
                    writeRequestSequence: writePacketArray[i].writeRequestSequence,
                    reqTime: process.hrtime.bigint(),
                });
                this_2.parallelJobsNow += 1;
                this_2.client.write(this_2.writeReq.slice(0, 19 + dataBufferPointer + writePacketArray[i].requestList.length * 12)); // was 31
                this_2.outputLog('Sending Write Packet With Sequence Number ' + writePacketArray[i].seqNum, 0, this_2.connectionId);
            }
            else {
                var timeHandler = function () {
                    _this.packetTimeout('write', writePacketArray[i].seqNum);
                };
                this_2.sentWritePacketArray.push({
                    requestList: writePacketArray[i].requestList,
                    sent: true,
                    rcvd: false,
                    seqNum: writePacketArray[i].seqNum,
                    timeout: setTimeout(timeHandler, this_2.globalTimeout),
                    writeRequestSequence: writePacketArray[i].writeRequestSequence,
                    reqTime: process.hrtime.bigint(),
                });
            }
        };
        var this_2 = this;
        for (var i = 0; i < writePacketArray.length; i++) {
            _loop_2(i);
        }
    };
    S7Comm.prototype.initiateConnection = function (callback) {
        this.connectCallback = callback;
        this.connectNow();
    };
    S7Comm.prototype.addItems = function (directions) {
        return __awaiter(this, void 0, void 0, function () {
            var addresses, _loop_3, this_3, i, err_1, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        addresses = [];
                        _loop_3 = function (i) {
                            var index = this_3.storedAdresses.findIndex(function (storedAddress) {
                                return storedAddress.name === _this.translationCB(directions[i]);
                            });
                            if (index >= 0 || typeof this_3.translationCB(directions[i]) === 'undefined') {
                                console.log(directions[i]);
                                directions.splice(index, 1);
                            }
                        };
                        this_3 = this;
                        for (i = directions.length - 1; i >= 0; i--) {
                            _loop_3(i);
                        }
                        if (directions.length === 0) {
                            return [2 /*return*/];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.stringArrayToS7AddressArray(directions, 'read')];
                    case 2:
                        addresses = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        return [2 /*return*/, Promise.reject(err_1)];
                    case 4:
                        for (i = 0; i < addresses.length; i++) {
                            this.storedAdresses.push(addresses[i]);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    S7Comm.prototype.removeItems = function (directions) {
        var _this = this;
        var _loop_4 = function (i) {
            var index = this_4.storedAdresses.findIndex(function (storedAddress) {
                return storedAddress.name === _this.translationCB(directions[i]);
            });
            if (index >= 0) {
                this_4.storedAdresses.splice(index, 1);
            }
        };
        var this_4 = this;
        for (var i = 0; i < directions.length; i++) {
            _loop_4(i);
        }
    };
    S7Comm.prototype.readItems = function (directions) {
        return __awaiter(this, void 0, void 0, function () {
            var addresses, err_2, promises, preparedReadRequest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isoConnectionState !== 's7comm') {
                            this.lastError = 'Unable to read when not connected.';
                            this.outputLog(this.lastError, 0, this.connectionId);
                            return [2 /*return*/, Promise.reject(new Error(this.lastError))];
                        }
                        if (!(directions instanceof Array)) {
                            this.lastError = 'Bad values given.';
                            this.outputLog(this.lastError, 0, this.connectionId);
                            return [2 /*return*/, Promise.reject(new Error(this.lastError))];
                        }
                        addresses = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.stringArrayToS7AddressArray(directions, 'read')];
                    case 2:
                        addresses = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_2 = _a.sent();
                        return [2 /*return*/, Promise.reject(err_2)];
                    case 4:
                        promises = [];
                        addresses.forEach(function (address) {
                            var promise = new Promise(function (resolve, reject) {
                                address.promiseResolve = resolve;
                                address.promiseReject = reject;
                            });
                            promises.push(promise);
                        });
                        preparedReadRequest = this.prepareReadPacket(addresses);
                        this.sendReadPacket(preparedReadRequest); // Note this sends the first few read packets depending on parallel connection restrictions.
                        return [2 /*return*/, Promise.all(promises)
                                .then(function (values) {
                                return Object.assign.apply(Object, __spreadArrays([{}], values));
                            })
                                .catch(function (err) {
                                throw new Error(err);
                            })];
                }
            });
        });
    };
    S7Comm.prototype.readAllItems = function () {
        return __awaiter(this, void 0, void 0, function () {
            var addresses, promises, preparedReadRequest;
            return __generator(this, function (_a) {
                if (this.isoConnectionState !== 's7comm') {
                    this.lastError = 'Unable to read when not connected.';
                    this.outputLog(this.lastError, 0, this.connectionId);
                    return [2 /*return*/, Promise.reject(new Error(this.lastError))];
                }
                if (this.storedAdresses.length === 0) {
                    return [2 /*return*/, Promise.resolve([])];
                }
                addresses = __spreadArrays(this.storedAdresses);
                promises = [];
                addresses.forEach(function (address) {
                    var promise = new Promise(function (resolve, reject) {
                        address.promiseResolve = resolve;
                        address.promiseReject = reject;
                    });
                    promises.push(promise);
                });
                preparedReadRequest = this.prepareReadPacket(addresses);
                this.sendReadPacket(preparedReadRequest); // Note this sends the first few read packets depending on parallel connection restrictions.
                return [2 /*return*/, Promise.all(promises)
                        .then(function (values) {
                        return Object.assign.apply(Object, __spreadArrays([{}], values));
                    })
                        .catch(function (err) {
                        throw new Error(err);
                    })];
            });
        });
    };
    S7Comm.prototype.writeItems = function (directions, value) {
        return __awaiter(this, void 0, void 0, function () {
            var addresses, err_3, instantWriteBlockList, promises, writePacketArray;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isoConnectionState !== 's7comm') {
                            this.lastError = 'Unable to write when not connected.';
                            this.outputLog(this.lastError, 0, this.connectionId);
                            return [2 /*return*/, Promise.reject(new Error(this.lastError))];
                        }
                        if (!(directions instanceof Array) || !(value instanceof Array)) {
                            this.lastError = 'Bad values given.';
                            this.outputLog(this.lastError, 0, this.connectionId);
                            return [2 /*return*/, Promise.reject(new Error(this.lastError))];
                        }
                        this.outputLog('Preparing to WRITE ' + directions + ' to value ' + value, 0, this.connectionId);
                        addresses = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.stringArrayToS7AddressArray(directions, 'write')];
                    case 2:
                        addresses = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_3 = _a.sent();
                        return [2 /*return*/, Promise.reject(err_3)];
                    case 4:
                        instantWriteBlockList = [];
                        promises = [];
                        addresses.forEach(function (address, index) {
                            var promise = new Promise(function (resolve, reject) {
                                address.promiseResolve = resolve;
                                address.promiseReject = reject;
                            });
                            var s7ItemWrite = _this.S7ItemWrite;
                            s7ItemWrite.address = address;
                            s7ItemWrite.writeValue = value[index];
                            instantWriteBlockList.push(s7ItemWrite);
                            promises.push(promise);
                        });
                        writePacketArray = this.prepareWritePacket(instantWriteBlockList);
                        this.sendWritePacket(writePacketArray);
                        return [2 /*return*/, Promise.all(promises)
                                .then(function (values) {
                                return Object.assign.apply(Object, __spreadArrays([{}], values));
                            })
                                .catch(function () {
                                throw new Error(_this.lastError);
                            })];
                }
            });
        });
    };
    Object.defineProperty(S7Comm.prototype, "Address", {
        get: function () {
            return {
                name: '',
                userName: '',
                Type: 'C',
                dataType: '',
                dbNumber: 0,
                bitOffset: 0,
                offset: 0,
                arrayLength: 0,
                dataTypeLength: 0,
                areaS7Code: 0x1c,
                byteLength: 0,
                byteLengthWithFill: 0,
                transportCode: 0x04,
                valid: true,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(S7Comm.prototype, "S7ItemWrite", {
        get: function () {
            return {
                address: this.Address,
                quality: '',
                writeQuality: '',
                writeResponse: 0,
                writeBuffer: Buffer.alloc(8192),
                writeValue: 0,
                valid: false,
                errCode: '',
                validResponseBuffer: false,
                resultReference: undefined,
            };
        },
        enumerable: true,
        configurable: true
    });
    return S7Comm;
}());
exports.S7Comm = S7Comm;
